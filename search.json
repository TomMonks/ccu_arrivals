[
  {
    "objectID": "02_applied/02_thinning_ccu.html",
    "href": "02_applied/02_thinning_ccu.html",
    "title": "NSPP via thinning",
    "section": "",
    "text": "This notebook provides an overview of how to use the time_dependent.NSPPThinning class.\nThinning is an acceptance-rejection approach to sampling inter-arrival times (IAT) from a time dependent distribution where each time period follows its own exponential distribution.\nThere are two random variables employed in sampling: an exponential distribution (used to sample IAT) and a uniform distibution (used to accept/reject samples).\nAll IATs are sampled from an Exponential distribution with the highest arrival rate (most frequent). These arrivals are then rejected (thinned) proportional to the ratio of the current arrival rate to the maximum arrival rate. The algorithm executes until a sample is accepted. The IAT returned is the sum of all the IATs that were sampled."
  },
  {
    "objectID": "02_applied/02_thinning_ccu.html#the-thinning-algorithm",
    "href": "02_applied/02_thinning_ccu.html#the-thinning-algorithm",
    "title": "NSPP via thinning",
    "section": "The thinning algorithm",
    "text": "The thinning algorithm\nA NSPP has arrival rate \\(\\lambda(t)\\) where \\(0 \\leq t \\leq T\\)\nHere \\(i\\) is the arrival number and \\(\\mathcal{T_i}\\) is its arrival time.\n\nLet \\(\\lambda^* = \\max_{0 \\leq t \\leq T}\\lambda(t)\\) be the maximum of the arrival rate function and set \\(t = 0\\) and \\(i=1\\)\nGenerate \\(e\\) from the exponential distribution with rate \\(\\lambda^*\\) and let \\(t = t + e\\) (this is the time of the next entity will arrive)\nGenerate \\(u\\) from the \\(U(0,1)\\) distribution. If \\(u \\leq \\dfrac{\\lambda(t)}{\\lambda^*}\\) then \\(\\mathcal{T_i} =t\\) and \\(i = i + 1\\)\nGo to Step 2."
  },
  {
    "objectID": "02_applied/02_thinning_ccu.html#sim-tools-imports",
    "href": "02_applied/02_thinning_ccu.html#sim-tools-imports",
    "title": "NSPP via thinning",
    "section": "sim-tools imports",
    "text": "sim-tools imports\n\nfrom sim_tools.datasets import load_banks_et_al_nspp\nfrom sim_tools.time_dependent import NSPPThinning"
  },
  {
    "objectID": "02_applied/02_thinning_ccu.html#general-imports",
    "href": "02_applied/02_thinning_ccu.html#general-imports",
    "title": "NSPP via thinning",
    "section": "general imports",
    "text": "general imports\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport simpy\nimport itertools\n\nplt.style.use('ggplot')"
  },
  {
    "objectID": "02_applied/02_thinning_ccu.html#example-from-banks-et-al.",
    "href": "02_applied/02_thinning_ccu.html#example-from-banks-et-al.",
    "title": "NSPP via thinning",
    "section": "Example from Banks et al.",
    "text": "Example from Banks et al.\nWe will illustrate the use of NSPPThinning using an example from Banks et al.Â \nThe table below breaks an arrival process down into 60 minutes intervals.\n\n\n\n\n\n\n\n\nt(min)\nMean time between arrivals (min)\nArrival Rate \\(\\lambda(t)\\) (arrivals/min)\n\n\n\n\n0\n15\n1/15\n\n\n60\n12\n1/12\n\n\n120\n7\n1/7\n\n\n180\n5\n1/5\n\n\n240\n8\n1/8\n\n\n300\n10\n1/10\n\n\n360\n15\n1/15\n\n\n420\n20\n1/20\n\n\n480\n20\n1/20\n\n\n\n\nInterpretation: In the table above the fastest arrival rate is 1/5 customers per minute or 5 minutes between customer arrivals.\n\n\nccu_arrival_profile_week = pd.read_csv('./data/weekday_profile.csv')\nccu_arrival_profile_week.round(1)\n\n\n\n\n\n\n\n\nt\narrival_rate\nmean_iat\n\n\n\n\n0\n0\n1.1\n55.5\n\n\n1\n60\n1.3\n46.1\n\n\n2\n120\n0.9\n69.3\n\n\n3\n180\n0.9\n67.2\n\n\n4\n240\n0.7\n85.1\n\n\n5\n300\n0.7\n81.1\n\n\n6\n360\n0.7\n90.0\n\n\n7\n420\n0.5\n115.1\n\n\n8\n480\n0.4\n145.0\n\n\n9\n540\n0.4\n141.1\n\n\n10\n600\n0.6\n99.1\n\n\n11\n660\n1.0\n62.1\n\n\n12\n720\n1.0\n60.5\n\n\n13\n780\n1.1\n56.3\n\n\n14\n840\n1.2\n50.8\n\n\n15\n900\n1.3\n45.1\n\n\n16\n960\n1.3\n47.7\n\n\n17\n1020\n1.4\n43.5\n\n\n18\n1080\n1.6\n36.7\n\n\n19\n1140\n1.4\n44.4\n\n\n20\n1200\n1.0\n58.2\n\n\n21\n1260\n1.2\n50.4\n\n\n22\n1320\n1.1\n52.9\n\n\n23\n1380\n1.3\n46.9"
  },
  {
    "objectID": "02_applied/02_thinning_ccu.html#model",
    "href": "02_applied/02_thinning_ccu.html#model",
    "title": "NSPP via thinning",
    "section": "Model",
    "text": "Model\nWe define a simple experiment and Time Dependent model used only for counting the number of arrivals in an hour using thinning.\n\nsimpy is used in a way to control for a fixed number of arrivals rather than a given run length.\n\n\nclass Experiment:\n    def __init__(self, arrival_profile,\n                 random_no_set=None):\n        self.arrival_profile = arrival_profile\n\n    def init_sampling(self, random_no_set=None):\n        # producing 2 non-overlapping streams\n        seed_sequence = np.random.SeedSequence(random_no_set)\n        self.seeds = seed_sequence.spawn(2)\n        \n        self.nspp_rng = NSPPThinning(self.arrival_profile, self.seeds[0], \n                                     self.seeds[1])\n        \n\n\nclass TimeDependentModel:\n    def __init__(self, env, experiment):\n        self.env = env\n        self.experiment = experiment\n        # create array hold arrivals per hour of day.\n        self.hour_samples = [0] * experiment.arrival_profile.shape[0]\n        self.arrival_times = []\n        self.n_arrivals = 0\n\n    def arrivals_generator(self):\n        for _ in itertools.count():\n            # simulated arrival\n            interarrival_time = self.experiment.nspp_rng.sample(self.env.now)\n            yield self.env.timeout(interarrival_time)\n\n            # Store the arrival time\n            self.arrival_times.append(self.env.now)\n\n            # store the IAT\n            \n                \n            # VERIFICATION: add one to count for hour of the day\n            hour_of_day = int(self.env.now // 60) % \\\n                self.experiment.arrival_profile.shape[0]\n            self.hour_samples[hour_of_day] += 1\n            self.n_arrivals += 1\n            \n\n\ndef single_run(experiment, run_length=1440, random_no_set=0):\n    \"\"\"\n    Run a single replication of the model.\n    \"\"\"\n    # sim environment\n    env = simpy.Environment()\n    experiment.init_sampling(random_no_set)\n    # create experiment and parameterise model\n    model = TimeDependentModel(env, experiment)\n\n    # set up simpy processes.\n    env.process(model.arrivals_generator())\n    env.run(run_length)\n\n    return model\n    \n\n\ndef multiple_replications(experiment, run_length=1440, n_reps=5):\n    '''\n    Perform multiple replications of the model.\n    \n    Params:\n    ------\n    experiment: Experiment\n        Parameters/arguments to configure the model\n    \n    run_length: float, optional (default=6540)\n        results collection period in minutes.\n        the number of minutes to run the model to collect results\n\n    n_reps: int, optional (default=5)\n        Number of independent replications to run.\n        \n    Returns:\n    --------\n    pandas.DataFrame\n    '''\n\n    results = [single_run(experiment, run_length, rep) \n               for rep in range(n_reps)]\n\n    arrival_hours = [model.hour_samples for model in results]\n    arrival_times = [model.arrival_times for model in results]\n    \n    # format and return results in a dataframe\n    df_hr_results = pd.DataFrame(arrival_hours)\n    df_hr_results.index = np.arange(1, len(df_hr_results)+1)\n    df_hr_results.index.name = 'rep'\n\n    arrival_times = np.concatenate(arrival_times).flatten()\n        \n    return df_hr_results, arrival_times\n\n\n# create experiment and parameterise model\nexperiment = Experiment(ccu_arrival_profile_week)\nhr_results, arrival_times = multiple_replications(experiment, run_length=1440, n_reps=10_000)\n\n\nhour_means = hr_results.mean(axis=0)\nhour_sd = hr_results.std(axis=0) \n\nupper = hour_means + hour_sd\nlower = hour_means - hour_sd\nlower[lower &lt; 0] = 0\n\n# visualise\nfig = plt.figure(figsize=(12,3))\nax = fig.add_subplot()\n\n# chart x ticks\nx_values = np.arange(0, ccu_arrival_profile_week.shape[0])\n\n# plot in this case returns a 2D line plot object\n_ = ax.plot(hour_means, label=\"NSPP via Thinning:Mean\")\n_ = ax.fill_between(x_values, lower, upper, alpha=0.2, label='NSPP via Thinning: +1SD')\n\n# read in mthod 3\nmethod3 = pd.read_csv(\"./ccu_method3.csv\")\n_ = ax.plot(method3[\"mean\"], label=\"Method3 Mean\")\n\n# chart appearance\n_ = ax.legend(loc=\"upper center\", ncol=3)\n_ = ax.set_ylim(0, 3.5)\n_ = ax.set_xlim(0, 23)\n_ = ax.set_ylabel(\"Patients\")\n_ = ax.set_xlabel(\"hour of simulation\")\n_ = plt.xticks(np.arange(0, ccu_arrival_profile_week.shape[0]))\n\n\n\n\n\nmethod3 = pd.read_csv(\"./ccu_method3.csv\")\n\n# create figure and subplots\nfig, axs = plt.subplots(nrows=3, ncols=1, tight_layout=True, figsize=(12,5),\n                        sharex=True)\n\n# 0 to 23 for x axis\nx_values = np.arange(0, ccu_arrival_profile_week.shape[0])\n\n# top plot is main comparison\n_ = axs[0].plot(hour_means, label=\"NSPP via Thinning:Mean\")\n_ = axs[0].fill_between(x_values, lower, upper, alpha=0.2, label='NSPP via Thinning: Mean +-1SD')\n_ = axs[0].plot(method3[\"mean\"], label=\"Method3 Mean\")\n\n# compare Mean +- 1*SDs\n_ = axs[1].fill_between(x_values, lower, upper, alpha=0.2, label='NSPP via Thinning: Mean +-1SD')\n_ = axs[1].fill_between(x_values, method3[\"-1SD\"], method3[\"+1SD\"], alpha=0.2, label='Method3: Mean +-1SD')\n\n# compare SD  \n_ = axs[2].plot(hour_sd, label=\"NSPP via Thinning:SD\")\n_ = axs[2].plot(method3[\"sd\"], label=\"Method3 SD\")\n\nfor ax in axs:\n    _ = ax.set_ylim(0, 4.0)\n    _ = ax.set_xlim(0, 23)\n    _ = ax.set_ylabel(\"Patients\")\n    _ = ax.legend(loc=\"upper center\", ncol=3)\n\n# format axes\n_ = plt.xticks(x_values)\n\n_ = axs[2].set_ylim(0, 2.0)\n_ = axs[2].set_xlabel(\"simulated hour of day\")\n\nfig.savefig(\"./comparison_weekday.png\")"
  },
  {
    "objectID": "02_applied/02_thinning_ccu.html#time-within-an-hour-variation",
    "href": "02_applied/02_thinning_ccu.html#time-within-an-hour-variation",
    "title": "NSPP via thinning",
    "section": "Time within an hour variation",
    "text": "Time within an hour variation\nNote that unlike method3, the NSPP via thinning approach is continuous and provides variation within an hour.\n\n# visualise\n\nfig = plt.figure(figsize=(12,3))\nax = fig.add_subplot()\n\n_ = ax.hist(arrival_times % 60.0)"
  },
  {
    "objectID": "01_theory/02_thinning_banks.html",
    "href": "01_theory/02_thinning_banks.html",
    "title": "NSPP via thinning",
    "section": "",
    "text": "This notebook provides an overview of how to use the time_dependent.NSPPThinning class.\nThinning is an acceptance-rejection approach to sampling inter-arrival times (IAT) from a time dependent distribution where each time period follows its own exponential distribution.\nThere are two random variables employed in sampling: an exponential distribution (used to sample IAT) and a uniform distibution (used to accept/reject samples).\nAll IATs are sampled from an Exponential distribution with the highest arrival rate (most frequent). These arrivals are then rejected (thinned) proportional to the ratio of the current arrival rate to the maximum arrival rate. The algorithm executes until a sample is accepted. The IAT returned is the sum of all the IATs that were sampled."
  },
  {
    "objectID": "01_theory/02_thinning_banks.html#the-thinning-algorithm",
    "href": "01_theory/02_thinning_banks.html#the-thinning-algorithm",
    "title": "NSPP via thinning",
    "section": "The thinning algorithm",
    "text": "The thinning algorithm\nA NSPP has arrival rate \\(\\lambda(t)\\) where \\(0 \\leq t \\leq T\\)\nHere \\(i\\) is the arrival number and \\(\\mathcal{T_i}\\) is its arrival time.\n\nLet \\(\\lambda^* = \\max_{0 \\leq t \\leq T}\\lambda(t)\\) be the maximum of the arrival rate function and set \\(t = 0\\) and \\(i=1\\)\nGenerate \\(e\\) from the exponential distribution with rate \\(\\lambda^*\\) and let \\(t = t + e\\) (this is the time of the next entity will arrive)\nGenerate \\(u\\) from the \\(U(0,1)\\) distribution. If \\(u \\leq \\dfrac{\\lambda(t)}{\\lambda^*}\\) then \\(\\mathcal{T_i} =t\\) and \\(i = i + 1\\)\nGo to Step 2."
  },
  {
    "objectID": "01_theory/02_thinning_banks.html#sim-tools-imports",
    "href": "01_theory/02_thinning_banks.html#sim-tools-imports",
    "title": "NSPP via thinning",
    "section": "sim-tools imports",
    "text": "sim-tools imports\n\nfrom sim_tools.datasets import load_banks_et_al_nspp\nfrom sim_tools.time_dependent import NSPPThinning"
  },
  {
    "objectID": "01_theory/02_thinning_banks.html#general-imports",
    "href": "01_theory/02_thinning_banks.html#general-imports",
    "title": "NSPP via thinning",
    "section": "general imports",
    "text": "general imports\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport simpy\nimport itertools"
  },
  {
    "objectID": "01_theory/02_thinning_banks.html#example-from-banks-et-al.",
    "href": "01_theory/02_thinning_banks.html#example-from-banks-et-al.",
    "title": "NSPP via thinning",
    "section": "Example from Banks et al.",
    "text": "Example from Banks et al.\nWe will illustrate the use of NSPPThinning using an example from Banks et al.Â \nThe table below breaks an arrival process down into 60 minutes intervals.\n\n\n\n\n\n\n\n\nt(min)\nMean time between arrivals (min)\nArrival Rate \\(\\lambda(t)\\) (arrivals/min)\n\n\n\n\n0\n15\n1/15\n\n\n60\n12\n1/12\n\n\n120\n7\n1/7\n\n\n180\n5\n1/5\n\n\n240\n8\n1/8\n\n\n300\n10\n1/10\n\n\n360\n15\n1/15\n\n\n420\n20\n1/20\n\n\n480\n20\n1/20\n\n\n\n\nInterpretation: In the table above the fastest arrival rate is 1/5 customers per minute or 5 minutes between customer arrivals.\n\n\nbanks_arrival_profile = load_banks_et_al_nspp()\nbanks_arrival_profile\n\n\n\n\n\n\n\n\nt\nmean_iat\narrival_rate\n\n\n\n\n0\n0\n15\n0.066667\n\n\n1\n60\n12\n0.083333\n\n\n2\n120\n7\n0.142857\n\n\n3\n180\n5\n0.200000\n\n\n4\n240\n8\n0.125000\n\n\n5\n300\n10\n0.100000\n\n\n6\n360\n15\n0.066667\n\n\n7\n420\n20\n0.050000\n\n\n8\n480\n20\n0.050000"
  },
  {
    "objectID": "01_theory/02_thinning_banks.html#model",
    "href": "01_theory/02_thinning_banks.html#model",
    "title": "NSPP via thinning",
    "section": "Model",
    "text": "Model\nWe define a simple experiment and Time Dependent model used only for counting the number of arrivals in an hour using thinning.\n\nsimpy is used in a way to control for a fixed number of arrivals rather than a given run length.\n\n\nclass Experiment:\n    def __init__(self, arrival_profile,\n                 random_no_set=None):\n        self.arrival_profile = arrival_profile\n\n    def init_sampling(self, random_no_set=None):\n        # producing 2 non-overlapping streams\n        seed_sequence = np.random.SeedSequence(random_no_set)\n        self.seeds = seed_sequence.spawn(2)\n        \n        self.nspp_rng = NSPPThinning(self.arrival_profile, self.seeds[0], \n                                     self.seeds[1])\n        \n\n\nclass TimeDependentModel:\n    def __init__(self, env, experiment):\n        self.env = env\n        self.experiment = experiment\n        # create array hold arrivals per hour of day.\n        self.samples = [0] * experiment.arrival_profile.shape[0]\n        self.n_arrivals = 0\n\n    def arrivals_generator(self):\n        for _ in itertools.count():\n            # simulated arrival\n            interarrival_time = self.experiment.nspp_rng.sample(self.env.now)\n            yield self.env.timeout(interarrival_time)\n    \n            # add one to count for hour of the day\n            hour_of_day = int(self.env.now // 60) % \\\n                self.experiment.arrival_profile.shape[0]\n            self.samples[hour_of_day] += 1\n            self.n_arrivals += 1\n\n\ndef single_run(experiment, run_length=540, random_no_set=0):\n    \"\"\"\n    Run a single replication of the model.\n    \"\"\"\n    # sim environment\n    env = simpy.Environment()\n    experiment.init_sampling(random_no_set)\n    # create experiment and parameterise model\n    model = TimeDependentModel(env, experiment)\n\n    # set up simpy processes.\n    env.process(model.arrivals_generator())\n    env.run(run_length)\n\n    return model.samples\n    \n\n\ndef multiple_replications(experiment, run_length=540, n_reps=5):\n    '''\n    Perform multiple replications of the model.\n    \n    Params:\n    ------\n    experiment: Experiment\n        Parameters/arguments to configure the model\n    \n    run_length: float, optional (default=6540)\n        results collection period in minutes.\n        the number of minutes to run the model to collect results\n\n    n_reps: int, optional (default=5)\n        Number of independent replications to run.\n        \n    Returns:\n    --------\n    pandas.DataFrame\n    '''\n\n    results = [single_run(experiment, run_length, rep) \n               for rep in range(n_reps)]\n    \n    #format and return results in a dataframe\n    df_results = pd.DataFrame(results)\n    df_results.index = np.arange(1, len(df_results)+1)\n    df_results.index.name = 'rep'\n    return df_results\n\n\n# create experiment and parameterise model\nexperiment = Experiment(banks_arrival_profile)\nresults = multiple_replications(experiment, run_length=540, n_reps=10_000)\n\nresults.mean(axis=0)\n\n0     3.9890\n1     4.7556\n2     7.8881\n3    11.6374\n4     7.8514\n5     6.1986\n6     4.3569\n7     3.2573\n8     3.0115\ndtype: float64\n\n\n\n# mean is average no arrivals in 1 hour. divide by 60 for per min.\nhour_means = results.mean(axis=0) / 60.0\n\n# visualise\nfig = plt.figure(figsize=(12,3))\nax = fig.add_subplot()\n\n# plot in this case returns a 2D line plot object\n_ = ax.plot(hour_means)\n\n# read in mthod 3\nmethod3 = pd.read_csv(\"./banks_method3.csv\")\n_ = ax.plot(method3)\n\n_ = ax.legend([\"NSPP via Thinning\", \"Block hourly arrivals (method 3)\"])\n\n_ = ax.set_xlabel(\"hour of simulation\")\n_ = ax.set_xlabel(\"arrivals/min\")"
  },
  {
    "objectID": "abstract.html",
    "href": "abstract.html",
    "title": "Results Summary",
    "section": "",
    "text": "This notebook compares two approaches to simulating a time dependent process where the number of events is Poisson distributed. In particular we explore a scenario where the number of events per hour follows hourly Poisson distributions. We include an applied example where the arrival rates across a 24 hour period is lows.\nWe investigate two methods:\n\nParameterising Poisson distributions per hour and sampling the number of events. We call this method3\nSampling the time between arrivals, called the inter-arrival time, from hourly Exponential distributions where interval overruns are corrected by thinning. This is a standard text book method for simulating a Non-Stationary Poisson Process (NSPP). We call this NSPP via Thinning\n\nMethod3 is a discrete approach that provides batch arrivals at the start of each hour. In a Discrete-Event Simulation (DES) it must be implented as a process that samples at the start of each hour. NSSP via Thinning provides continuous inter-arrival times i.e.Â spread the arrival across hours instead of batching at the beginning of the hour. It is implemented into a DES in the same manner as any statistical distribution.\n\nOur concern with NSPP via thinning in the case of a CCU is that the number of arrivals per hour is very low. Sometimes less than zero. The comparison with the method3 allows for a check that it is working as expected."
  },
  {
    "objectID": "abstract.html#background",
    "href": "abstract.html#background",
    "title": "Results Summary",
    "section": "",
    "text": "This notebook compares two approaches to simulating a time dependent process where the number of events is Poisson distributed. In particular we explore a scenario where the number of events per hour follows hourly Poisson distributions. We include an applied example where the arrival rates across a 24 hour period is lows.\nWe investigate two methods:\n\nParameterising Poisson distributions per hour and sampling the number of events. We call this method3\nSampling the time between arrivals, called the inter-arrival time, from hourly Exponential distributions where interval overruns are corrected by thinning. This is a standard text book method for simulating a Non-Stationary Poisson Process (NSPP). We call this NSPP via Thinning\n\nMethod3 is a discrete approach that provides batch arrivals at the start of each hour. In a Discrete-Event Simulation (DES) it must be implented as a process that samples at the start of each hour. NSSP via Thinning provides continuous inter-arrival times i.e.Â spread the arrival across hours instead of batching at the beginning of the hour. It is implemented into a DES in the same manner as any statistical distribution.\n\nOur concern with NSPP via thinning in the case of a CCU is that the number of arrivals per hour is very low. Sometimes less than zero. The comparison with the method3 allows for a check that it is working as expected."
  },
  {
    "objectID": "abstract.html#methods",
    "href": "abstract.html#methods",
    "title": "Results Summary",
    "section": "Methods",
    "text": "Methods\nWe compare the two methods using the mean number of arrivals per hour on a weekday versus a weekend. In the case of method3 the expected answer is straighforward as the number of events is the rate parameter of the distributions. For method3, we therefore simply draw 10,000 samples from each hour. For a NSPP via thinning, we conduct 10,000 replications of a single simulated day and tabulate the number of arrivals per hour. A secondary measure is the standard deviation of the number of arrivals per hour.\nWe conduct this analysis for a simple theoretical example from Banks et al and applied to real values from a CCU."
  },
  {
    "objectID": "abstract.html#results",
    "href": "abstract.html#results",
    "title": "Results Summary",
    "section": "Results",
    "text": "Results\nThe theoretical results comparing mean number of arrivals per hour were identical. Figure 1 demonstrates that the results from the CCU applied example. This shows that method3 and NSPP via thinning are qualitatively the same. NSPP Thinning smooths the mean number of arrivals per hour to a small extent. Variation in the number of arrivals per hour is similar with identical standard deviations."
  },
  {
    "objectID": "abstract.html#conclusions",
    "href": "abstract.html#conclusions",
    "title": "Results Summary",
    "section": "Conclusions",
    "text": "Conclusions\nTo simulate the number of arrivals per hour in a CCU either method3 or NSPP via thinning can be employed. Results are for all practical purposes identical. If variation within an hour is required NSPP via thinning should be employed over method3. NSPP via thinning may also be simpler to implement in simulation software. Although method3 and NSPP via thinning are suitable for simulating the mean number of arrivals, a limitation of this analysis is that we do not consider if the empirical number of arrivals in the CCU truely follows a Poisson process."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "A comparison of method3 and NSPP via thinning",
    "section": "",
    "text": "This notebook compares two approaches to simulating a time dependent process where the number of events is Poisson distributed. In particular we explore a scenario where the number of events per hour follows hourly Poisson distributions. We include an applied example where the arrival rates across a 24 hour period is lows.\nWe investigate two methods:\n\nParameterising Poisson distributions per hour and sampling the number of events. We call this method3\nSampling the time between arrivals, called the inter-arrival time, from hourly Exponential distributions where interval overruns are corrected by thinning. This is a standard text book method for simulating a Non-Stationary Poisson Process (NSPP). We call this NSPP via Thinning\n\nMethod3 is a discrete approach that provides batch arrivals at the start of each hour. In a Discrete-Event Simulation (DES) it must be implented as a process that samples at the start of each hour. NSSP via Thinning provides continuous inter-arrival times i.e.Â spread the arrival across hours instead of batching at the beginning of the hour. It is implemented into a DES in the same manner as any statistical distribution.\n\nOur concern with NSPP via thinning in the case of a CCU is that the number of arrivals per hour is very low. Sometimes less than zero. The comparison with the method3 allows for a check that it is working as expected."
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "A comparison of method3 and NSPP via thinning",
    "section": "",
    "text": "This notebook compares two approaches to simulating a time dependent process where the number of events is Poisson distributed. In particular we explore a scenario where the number of events per hour follows hourly Poisson distributions. We include an applied example where the arrival rates across a 24 hour period is lows.\nWe investigate two methods:\n\nParameterising Poisson distributions per hour and sampling the number of events. We call this method3\nSampling the time between arrivals, called the inter-arrival time, from hourly Exponential distributions where interval overruns are corrected by thinning. This is a standard text book method for simulating a Non-Stationary Poisson Process (NSPP). We call this NSPP via Thinning\n\nMethod3 is a discrete approach that provides batch arrivals at the start of each hour. In a Discrete-Event Simulation (DES) it must be implented as a process that samples at the start of each hour. NSSP via Thinning provides continuous inter-arrival times i.e.Â spread the arrival across hours instead of batching at the beginning of the hour. It is implemented into a DES in the same manner as any statistical distribution.\n\nOur concern with NSPP via thinning in the case of a CCU is that the number of arrivals per hour is very low. Sometimes less than zero. The comparison with the method3 allows for a check that it is working as expected."
  },
  {
    "objectID": "index.html#methods",
    "href": "index.html#methods",
    "title": "A comparison of method3 and NSPP via thinning",
    "section": "Methods",
    "text": "Methods\nWe compare the two methods using the mean number of arrivals per hour on a weekday versus a weekend. In the case of method3 the expected answer is straighforward as the number of events is the rate parameter of the distributions. For method3, we therefore simply draw 10,000 samples from each hour. For a NSPP via thinning, we conduct 10,000 replications of a single simulated day and tabulate the number of arrivals per hour. A secondary measure is the standard deviation of the number of arrivals per hour.\nWe conduct this analysis for a simple theoretical example from Banks et al and applied to real values from a CCU."
  },
  {
    "objectID": "index.html#results",
    "href": "index.html#results",
    "title": "A comparison of method3 and NSPP via thinning",
    "section": "Results",
    "text": "Results\nThe theoretical results comparing mean number of arrivals per hour were identical. Figure 1 demonstrates that the results from the CCU applied example. This shows that method3 and NSPP via thinning are qualitatively the same. NSPP Thinning smooths the mean number of arrivals per hour to a small extent. Variation in the number of arrivals per hour is similar with identical standard deviations."
  },
  {
    "objectID": "index.html#conclusions",
    "href": "index.html#conclusions",
    "title": "A comparison of method3 and NSPP via thinning",
    "section": "Conclusions",
    "text": "Conclusions\nTo simulate the number of arrivals per hour in a CCU either method3 or NSPP via thinning can be employed. Results are for all practical purposes identical. If variation within an hour is required NSPP via thinning should be employed over method3. NSPP via thinning may also be simpler to implement in simulation software. Although method3 and NSPP via thinning are suitable for simulating the mean number of arrivals, a limitation of this analysis is that we do not consider if the empirical number of arrivals in the CCU truely follows a Poisson process."
  },
  {
    "objectID": "01_theory/01_method3_banks.html",
    "href": "01_theory/01_method3_banks.html",
    "title": "Method3",
    "section": "",
    "text": "This notebook generates the hourly number of arrivals using a Poisson distribution for each hour. We do using the example from Banks et al."
  },
  {
    "objectID": "01_theory/01_method3_banks.html#example-from-banks-et-al.",
    "href": "01_theory/01_method3_banks.html#example-from-banks-et-al.",
    "title": "Method3",
    "section": "Example from Banks et al.",
    "text": "Example from Banks et al.\nWe will illustrate the use of NSPPThinning using an example from Banks et al.Â \nThe table below breaks an arrival process down into 60 minutes intervals.\n\n\n\n\n\n\n\n\nt(min)\nMean time between arrivals (min)\nArrival Rate \\(\\lambda(t)\\) (arrivals/min)\n\n\n\n\n0\n15\n1/15\n\n\n60\n12\n1/12\n\n\n120\n7\n1/7\n\n\n180\n5\n1/5\n\n\n240\n8\n1/8\n\n\n300\n10\n1/10\n\n\n360\n15\n1/15\n\n\n420\n20\n1/20\n\n\n480\n20\n1/20\n\n\n\n\nInterpretation: In the table above the fastest arrival rate is 1/5 customers per minute or 5 minutes between customer arrivals."
  },
  {
    "objectID": "01_theory/01_method3_banks.html#imports",
    "href": "01_theory/01_method3_banks.html#imports",
    "title": "Method3",
    "section": "Imports",
    "text": "Imports\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom sim_tools.datasets import load_banks_et_al_nspp\nimport sim_tools\nsim_tools.__version__\n\n/tmp/ipykernel_1134562/3514245499.py:1: DeprecationWarning: \nPyarrow will become a required dependency of pandas in the next major release of pandas (pandas 3.0),\n(to allow more performant data types, such as the Arrow string type, and better interoperability with other libraries)\nbut was not found to be installed on your system.\nIf this would cause problems for you,\nplease provide us feedback at https://github.com/pandas-dev/pandas/issues/54466\n        \n  import pandas as pd\n\n\n'0.5.0'"
  },
  {
    "objectID": "01_theory/01_method3_banks.html#arrival-profile-data",
    "href": "01_theory/01_method3_banks.html#arrival-profile-data",
    "title": "Method3",
    "section": "Arrival Profile Data",
    "text": "Arrival Profile Data\nWe will use the arrival_rate column as the parameter of the individual Poisson distributions.\n\nbanks_arrival_profile = load_banks_et_al_nspp()\nbanks_arrival_profile\n\n\n\n\n\n\n\n\nt\nmean_iat\narrival_rate\n\n\n\n\n0\n0\n15\n0.066667\n\n\n1\n60\n12\n0.083333\n\n\n2\n120\n7\n0.142857\n\n\n3\n180\n5\n0.200000\n\n\n4\n240\n8\n0.125000\n\n\n5\n300\n10\n0.100000\n\n\n6\n360\n15\n0.066667\n\n\n7\n420\n20\n0.050000\n\n\n8\n480\n20\n0.050000"
  },
  {
    "objectID": "01_theory/01_method3_banks.html#sampler",
    "href": "01_theory/01_method3_banks.html#sampler",
    "title": "Method3",
    "section": "Sampler",
    "text": "Sampler\nA class has been created to simplify the sampling.\n\nclass HourPoissonSampler:\n    def __init__(self, arrival_profile, random_seed=None):\n        self.arrival_profile = arrival_profile\n        self.rng = np.random.default_rng(random_seed)\n\n    def sample(self, hour, size=None):\n        '''Sample the number of arrivals in a given hour\n\n        Parameters:\n        ---------\n        hour: int\n            Zero indexed hour\n\n        size: int, optional (default=None)\n            Number of samples to return. None returns 1.\n\n        Returns:\n        -------\n        np.array or float\n        \n        '''\n        rate = self.arrival_profile.iloc[hour]['arrival_rate']\n        return self.rng.poisson(rate, size=size)"
  },
  {
    "objectID": "01_theory/01_method3_banks.html#using-the-sampler",
    "href": "01_theory/01_method3_banks.html#using-the-sampler",
    "title": "Method3",
    "section": "Using the sampler",
    "text": "Using the sampler\n\nsamples_per_hour = 100_000\n\n# create the sampler and set seed\nph_sampler = HourPoissonSampler(banks_arrival_profile, random_seed=42)\n\n# returns numpy array for hour 1\nhr_sample = ph_sampler.sample(0, size=samples_per_hour)\nhr_sample.shape\n\n(100000,)\n\n\n\n# first 10 results\nhr_sample[:10]\n\narray([0, 0, 0, 0, 0, 1, 0, 0, 0, 0])\n\n\n\n# mean arrival rate as expected - its our rate parameter og 0.067 per hr.\nhr_sample.mean()\n\n0.06723"
  },
  {
    "objectID": "01_theory/01_method3_banks.html#sampling-experiment",
    "href": "01_theory/01_method3_banks.html#sampling-experiment",
    "title": "Method3",
    "section": "Sampling experiment",
    "text": "Sampling experiment\n\nph_sampler = HourPoissonSampler(banks_arrival_profile, random_seed=42)\n\nsamples = []\nfor hr in range(len(banks_arrival_profile)):\n    hr_sample = ph_sampler.sample(hr, size=samples_per_hour)\n    samples.append(hr_sample)"
  },
  {
    "objectID": "01_theory/01_method3_banks.html#plot-results",
    "href": "01_theory/01_method3_banks.html#plot-results",
    "title": "Method3",
    "section": "Plot results",
    "text": "Plot results\nThe hour means are our theorectical arrival rates per hour - as expected.\n\n# get hour means\nhour_means = np.asarray(samples).mean(axis=1)\n\n# visualise\nfig = plt.figure(figsize=(12,3))\nax = fig.add_subplot()\n\n# plot in this case returns a 2D line plot object\n_ = ax.plot(hour_means)\n\n\n\n\n\npd.DataFrame(hour_means).to_csv(\"./banks_method3.csv\", index=False)"
  },
  {
    "objectID": "02_applied/01_method3_ccu.html",
    "href": "02_applied/01_method3_ccu.html",
    "title": "Method 3",
    "section": "",
    "text": "This notebook generates the hourly number of arrivals using a Poisson distribution for each hour. This is applied to the example from thr CCU weekday dataset."
  },
  {
    "objectID": "02_applied/01_method3_ccu.html#imports",
    "href": "02_applied/01_method3_ccu.html#imports",
    "title": "Method 3",
    "section": "Imports",
    "text": "Imports\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nplt.style.use('ggplot')\n\nfrom sim_tools.datasets import load_banks_et_al_nspp\nimport sim_tools\nsim_tools.__version__\n\n'0.5.0'"
  },
  {
    "objectID": "02_applied/01_method3_ccu.html#arrival-profile-data",
    "href": "02_applied/01_method3_ccu.html#arrival-profile-data",
    "title": "Method 3",
    "section": "Arrival Profile Data",
    "text": "Arrival Profile Data\nWe will use the arrival_rate column as the parameter of the individual Poisson distributions.\n\nccu_arrival_profile_week = pd.read_csv('./data/weekday_profile.csv')\nccu_arrival_profile_week.round(1)\n\n\n\n\n\n\n\n\nt\narrival_rate\nmean_iat\n\n\n\n\n0\n0\n1.1\n55.5\n\n\n1\n60\n1.3\n46.1\n\n\n2\n120\n0.9\n69.3\n\n\n3\n180\n0.9\n67.2\n\n\n4\n240\n0.7\n85.1\n\n\n5\n300\n0.7\n81.1\n\n\n6\n360\n0.7\n90.0\n\n\n7\n420\n0.5\n115.1\n\n\n8\n480\n0.4\n145.0\n\n\n9\n540\n0.4\n141.1\n\n\n10\n600\n0.6\n99.1\n\n\n11\n660\n1.0\n62.1\n\n\n12\n720\n1.0\n60.5\n\n\n13\n780\n1.1\n56.3\n\n\n14\n840\n1.2\n50.8\n\n\n15\n900\n1.3\n45.1\n\n\n16\n960\n1.3\n47.7\n\n\n17\n1020\n1.4\n43.5\n\n\n18\n1080\n1.6\n36.7\n\n\n19\n1140\n1.4\n44.4\n\n\n20\n1200\n1.0\n58.2\n\n\n21\n1260\n1.2\n50.4\n\n\n22\n1320\n1.1\n52.9\n\n\n23\n1380\n1.3\n46.9"
  },
  {
    "objectID": "02_applied/01_method3_ccu.html#sampler",
    "href": "02_applied/01_method3_ccu.html#sampler",
    "title": "Method 3",
    "section": "Sampler",
    "text": "Sampler\nA class has been created to simplify the sampling.\n\nclass HourPoissonSampler:\n    def __init__(self, arrival_profile, random_seed=None):\n        self.arrival_profile = arrival_profile\n        self.rng = np.random.default_rng(random_seed)\n\n    def sample(self, hour, size=None):\n        '''Sample the number of arrivals in a given hour\n\n        Parameters:\n        ---------\n        hour: int\n            Zero indexed hour\n\n        size: int, optional (default=None)\n            Number of samples to return. None returns 1.\n\n        Returns:\n        -------\n        np.array or float\n        \n        '''\n        rate = self.arrival_profile.iloc[hour]['arrival_rate']\n        return self.rng.poisson(rate, size=size)"
  },
  {
    "objectID": "02_applied/01_method3_ccu.html#using-the-sampler",
    "href": "02_applied/01_method3_ccu.html#using-the-sampler",
    "title": "Method 3",
    "section": "Using the sampler",
    "text": "Using the sampler\n\nsamples_per_hour = 10_000\n\n# create the sampler and set seed\nph_sampler = HourPoissonSampler(ccu_arrival_profile_week, random_seed=42)\n\n# returns numpy array for hour 1\nhr_sample = ph_sampler.sample(0, size=samples_per_hour)\nhr_sample.shape\n\n(10000,)\n\n\n\n# first 10 results\nhr_sample[:10]\n\narray([2, 1, 3, 1, 3, 0, 1, 3, 3, 1])\n\n\n\n# mean arrival rate as expected - its our rate parameter og 0.067 per hr.\nhr_sample.mean().round(1)\n\n1.1"
  },
  {
    "objectID": "02_applied/01_method3_ccu.html#sampling-experiment",
    "href": "02_applied/01_method3_ccu.html#sampling-experiment",
    "title": "Method 3",
    "section": "Sampling experiment",
    "text": "Sampling experiment\n\nph_sampler = HourPoissonSampler(ccu_arrival_profile_week, random_seed=42)\n\nsamples = []\nfor hr in range(len(ccu_arrival_profile_week)):\n    hr_sample = ph_sampler.sample(hr, size=samples_per_hour)\n    samples.append(hr_sample)"
  },
  {
    "objectID": "02_applied/01_method3_ccu.html#plot-results",
    "href": "02_applied/01_method3_ccu.html#plot-results",
    "title": "Method 3",
    "section": "Plot results",
    "text": "Plot results\nThe hour means are our theorectical arrival rates per hour - as expected.\n\n# get hour means\nhour_means = np.asarray(samples).mean(axis=1)\nhour_sd = np.asarray(samples).std(axis=1) \n\nupper = hour_means + hour_sd\nlower = hour_means - hour_sd\nlower[lower &lt; 0] = 0\n\nx_values = np.arange(0, ccu_arrival_profile_week.shape[0])\n\n# visualise\nfig = plt.figure(figsize=(12,3))\nax = fig.add_subplot()\n\n# plot in this case returns a 2D line plot object\n_ = ax.plot(hour_means, label='Method3: Mean')\n_ = ax.fill_between(x_values, lower, upper, alpha=0.2, label='Method3: +1SD')\n_ = ax.set_ylim(0, 3.5)\n_ = ax.set_xlim(0, 23)\n_ = plt.xticks(np.arange(0, ccu_arrival_profile_week.shape[0]))\n_ = ax.set_ylabel(\"Patients\")\n_ = ax.set_xlabel(\"hour of simulation\")\n_ = ax.legend()\n\n\n\n\n\nmethod3_output = pd.DataFrame(hour_means, columns=[\"mean\"])\nmethod3_output['-1SD'] = lower\nmethod3_output['+1SD'] = upper\nmethod3_output['sd'] = hour_sd\nmethod3_output.to_csv(\"./ccu_method3.csv\", index=False)"
  }
]